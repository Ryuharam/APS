백트래킹
  완전 탐색 vs 백트래킹
    - 완전탐색(브루트 포스)는 모든 경우의 수 고려
    - 백트래킹은 일반적으로 경우의 수가 줄어들지만 최악의 경우에는 여전히 지수 함수 시간을 요함
      -> 가지치기가 거의 이루어지지 않은 상황
      -> 문제가 매우 큰 입력을 가지는 상황
      -> 유효한 해답이 거의 없는 상황
      ...
  N-Queen
    - N*N 크기의 체스판 위에 N개의 Queen들을 서로 위협하지 않게 배치하는 문제
    8-Queen
      - 모든 경우의 수는 64C8 = 4,426,165,368
      - 실제 정답의 수는 92개
      - 모든 경우의 수 속에서 92개를 효율적으로 찾아내는 것이 관건
    4-Queen
      - 같은 행에는 퀸을 놓을 수 없음
      - 따라서 모든 경우의 수는 4*4*4*4 = 256가지
      - 재귀함수를 이용해 구현
      - 상태공간트리
  햄버거 다이어트
    - 재료의 개수 N : 최대 20개. 부분집합으로 풀 경우 2^20 
    - 비트마스킹으로 풀 수 있다.
    - 중간에 제한 칼로리를 넘어가는 경우 더 진행 할 필요 없음

순열
  라면 끓이기
    - 
  순열 : 서로 다른 원소들을 특정한 순서로 나열하는 것
    - 서로 다른 n개의 원소를 가지는 집합에서 r개를 뽑아서 순서 있게 나열하는 경우를 다음과 같이 표현할 수 있음
      -> nPr
  순열을 활용하는 문제
    - 0 ~ 9 까지의 숫자를 활용하여 4자리의 비밀번호를 만드는 경우 만들 수 있는 경우의 수를 구하시오
    - 5명의 사람을 줄을 세우려고 합니다. 경우의 수를 구하시오
    - A, B, C, D 도시가 있습니다. 방문할 수 있는 경우의 수는 얼마인지 구하시오
    - 등
순열 구현  
  arr = {1,2,3} 이 있을 때 모든 순열을 생성해 보시오
    1. 반복문
      - 중복을 방지하기 위해 for문과 if문 같이 필요
    2. swap
      - 나 와 다음 수를 swap
      - 다시 swap 되지 않게 주의
      - 사전 순서대로 출력되지 않음
      - 원본 자체를 swap 후 출력, 그 다음 다시 원상 복구하기 위해 swap
      - 따라서, 추가적인 tmp가 필요하지 않다.
    3. 방문체크
      - boolean[] visited 필요
        - 1. 사용했으면 넘어감. continue
        - 2. 사용하지 않았다면 if() { 여기 작성 }
      - 결과를 저장할 추가적인 공간 필요
    4. 비트마스킹
      - int visited : 사용한 원소를 기록하기 위한 정수
      - visited & (1<<i) != 0 
      - 재귀 돌릴 때 visited 인자로 넣어주면 다시 되돌리는 과정 필요 없음
      - visited | (1<<i)
      - 기저 조건 : visited == ((1<<N)-1) return;
      - 결과를 모아서 보려고 했을 때, 얕은 복사 주의!

  순열 확장 개념
    - 중복 순열
    - 원형 순열
